# Orchestration Sidecar API Reference

**Version**: 1.0.0
**Date**: November 2025
**Base URL**: `http://localhost:3001/api`

## Table of Contents

1. [Overview](#overview)
2. [Authentication](#authentication)
3. [Endpoints](#endpoints)
   - [GET /api/context/:issue_id/:agent_type](#get-context)
   - [POST /api/results](#post-results)
   - [POST /api/events/:event_type](#post-events)
   - [GET /api/events/wait/:event_type](#get-events-wait)
   - [POST /api/agents/spawn](#post-agents-spawn)
   - [DELETE /api/cache/context/:issue_id](#delete-cache)
   - [GET /health](#get-health)
   - [GET /status](#get-status)
4. [Error Codes](#error-codes)
5. [Rate Limiting](#rate-limiting)
6. [Examples](#examples)

---

## Overview

The Orchestration Sidecar API provides HTTP endpoints for agent coordination, context injection, event messaging, and result storage. All endpoints use JSON for request/response payloads.

### Base URL

```
http://localhost:3001/api
```

### Protocol

- **HTTP/1.1** and **HTTP/2** supported
- **TLS/HTTPS** optional (recommended for production)
- **CORS** enabled for browser access

### Content Type

All requests and responses use:

```
Content-Type: application/json
```

---

## Authentication

All agent API requests require JWT authentication via the `Authorization` header.

### Authorization Header

```http
Authorization: Bearer <jwt-token>
```

### JWT Token Structure

```json
{
  "sub": "agent-uuid-12345",
  "agent_type": "python-specialist",
  "project_id": "project-abc",
  "permissions": [
    "read_context",
    "write_results",
    "publish_events"
  ],
  "exp": 1700000000,
  "iat": 1699990000
}
```

### Obtaining Tokens

Tokens are automatically generated by the sidecar when spawning agents:

```bash
# Spawn agent and receive JWT token
cco agent spawn --type python-specialist --issue issue-123

# Token is injected into agent environment
echo $JWT_TOKEN
```

### Token Expiration

- **Default TTL**: 1 hour
- **Auto-refresh**: Tokens refresh automatically 5 minutes before expiry
- **Expired tokens**: Return `401 Unauthorized`

### Permission Model

| Permission | Description | Agent Types |
|-----------|-------------|-------------|
| `read_context` | Retrieve project context | All agents |
| `write_results` | Store agent outputs | Coding, QA, Security |
| `publish_events` | Publish to event bus | All except Documentation |
| `spawn_agents` | Create new agents | Chief Architect only |

---

## Endpoints

### GET /api/context/:issue_id/:agent_type {#get-context}

Retrieve context for a specific agent and task.

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `issue_id` | Path | Yes | Issue/task identifier |
| `agent_type` | Path | Yes | Agent type (e.g., `python-specialist`) |

#### Request Example

```bash
# cURL
curl -H "Authorization: Bearer eyJhbGci..." \
  http://localhost:3001/api/context/issue-123/python-specialist

# Python
import requests

headers = {"Authorization": f"Bearer {jwt_token}"}
response = requests.get(
    "http://localhost:3001/api/context/issue-123/python-specialist",
    headers=headers
)
context = response.json()

# Rust
use reqwest::header::{HeaderMap, HeaderValue, AUTHORIZATION};

let mut headers = HeaderMap::new();
headers.insert(AUTHORIZATION, HeaderValue::from_str(&format!("Bearer {}", jwt_token))?);

let client = reqwest::Client::new();
let response = client
    .get("http://localhost:3001/api/context/issue-123/python-specialist")
    .headers(headers)
    .send()
    .await?;

let context: Context = response.json().await?;
```

#### Response Schema

```json
{
  "issue_id": "issue-123",
  "agent_type": "python-specialist",
  "context": {
    "project_structure": {
      "root": "/Users/project",
      "files": ["src/main.py", "tests/test_main.py"],
      "directories": ["src", "tests", "docs"],
      "total_files": 42,
      "total_size_bytes": 512000
    },
    "relevant_files": [
      {
        "path": "src/main.py",
        "content": "def main():\n    pass",
        "last_modified": "2025-11-18T10:00:00Z",
        "size": 1024,
        "language": "python",
        "checksum": "sha256:abc123..."
      },
      {
        "path": "tests/test_main.py",
        "content": "def test_main():\n    assert True",
        "last_modified": "2025-11-18T10:00:00Z",
        "size": 512,
        "language": "python",
        "checksum": "sha256:def456..."
      }
    ],
    "git_context": {
      "branch": "main",
      "recent_commits": [
        {
          "hash": "abc123",
          "message": "Initial commit",
          "author": "developer",
          "timestamp": "2025-11-18T09:00:00Z",
          "files_changed": ["src/main.py"]
        }
      ],
      "uncommitted_changes": [
        {
          "path": "src/api.py",
          "status": "modified",
          "diff": "+10 -5"
        }
      ],
      "remote": "origin",
      "remote_url": "https://github.com/org/project"
    },
    "previous_agent_outputs": [
      {
        "agent": "chief-architect",
        "agent_type": "chief-architect",
        "timestamp": "2025-11-18T09:30:00Z",
        "decision": "Use FastAPI for the backend",
        "rationale": "Best performance for async endpoints",
        "files_affected": ["requirements.txt"]
      }
    ],
    "metadata": {
      "project_type": "python",
      "dependencies": ["fastapi", "pytest", "pydantic"],
      "python_version": "3.11",
      "test_coverage": 85.5,
      "last_build_status": "success",
      "last_build_time": "2025-11-18T09:00:00Z",
      "security_scan_status": "passed"
    }
  },
  "truncated": false,
  "truncation_strategy": "none",
  "total_size_bytes": 102400,
  "file_count": 12,
  "timestamp": "2025-11-18T10:00:00Z",
  "cache_hit": true
}
```

#### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `issue_id` | string | Task identifier |
| `agent_type` | string | Agent type receiving context |
| `context` | object | Full context object |
| `context.project_structure` | object | Directory and file structure |
| `context.relevant_files` | array | Files relevant to agent type |
| `context.git_context` | object | Git repository information |
| `context.previous_agent_outputs` | array | Results from previous agents |
| `context.metadata` | object | Project metadata |
| `truncated` | boolean | Whether context was truncated |
| `truncation_strategy` | string | How truncation was applied |
| `total_size_bytes` | number | Total context size in bytes |
| `file_count` | number | Number of files in context |
| `timestamp` | string | ISO 8601 timestamp |
| `cache_hit` | boolean | Whether context came from cache |

#### Status Codes

| Code | Description |
|------|-------------|
| `200 OK` | Context retrieved successfully |
| `401 Unauthorized` | Invalid or missing JWT token |
| `403 Forbidden` | Agent lacks `read_context` permission |
| `404 Not Found` | Issue or agent type not found |
| `500 Internal Server Error` | Context generation failed |

#### Errors

```json
{
  "error": "unauthorized",
  "message": "Invalid or expired JWT token",
  "code": "AUTH_001",
  "timestamp": "2025-11-18T10:00:00Z"
}
```

---

### POST /api/results {#post-results}

Store agent execution results.

#### Request Schema

```json
{
  "agent_id": "python-specialist-uuid",
  "agent_type": "python-specialist",
  "issue_id": "issue-123",
  "project_id": "project-abc",
  "result": {
    "status": "success",
    "files_created": [
      {
        "path": "src/api.py",
        "size": 4096,
        "language": "python",
        "checksum": "sha256:abc123..."
      },
      {
        "path": "tests/test_api.py",
        "size": 2048,
        "language": "python",
        "checksum": "sha256:def456..."
      }
    ],
    "files_modified": [
      {
        "path": "requirements.txt",
        "diff": "+1 -0",
        "changes": ["Added fastapi==0.104.0"]
      }
    ],
    "files_deleted": [],
    "decisions": [
      "Implemented REST API with FastAPI",
      "Added comprehensive test suite",
      "Used Pydantic models for validation"
    ],
    "metrics": {
      "execution_time_ms": 4500,
      "tokens_used": 15000,
      "test_coverage": 92.3,
      "lines_of_code": 250,
      "complexity_score": 3.2
    },
    "artifacts": {
      "api_documentation": "# API Documentation\n\n## Endpoints\n...",
      "test_report": "All tests passing (15/15)",
      "performance_report": "API responds in <50ms"
    },
    "errors": [],
    "warnings": [
      "Consider adding rate limiting to endpoints",
      "Missing OpenAPI tags on 2 endpoints"
    ],
    "next_steps": [
      "Security audit required",
      "Load testing recommended"
    ]
  },
  "timestamp": "2025-11-18T10:05:00Z"
}
```

#### Request Examples

```bash
# cURL
curl -X POST \
  -H "Authorization: Bearer eyJhbGci..." \
  -H "Content-Type: application/json" \
  -d '{
    "agent_id": "python-specialist-uuid",
    "agent_type": "python-specialist",
    "issue_id": "issue-123",
    "project_id": "project-abc",
    "result": {
      "status": "success",
      "files_created": ["src/api.py"],
      "decisions": ["Implemented REST API"]
    }
  }' \
  http://localhost:3001/api/results

# Python
import requests

result_data = {
    "agent_id": "python-specialist-uuid",
    "agent_type": "python-specialist",
    "issue_id": "issue-123",
    "project_id": "project-abc",
    "result": {
        "status": "success",
        "files_created": ["src/api.py"],
        "decisions": ["Implemented REST API"]
    }
}

headers = {"Authorization": f"Bearer {jwt_token}"}
response = requests.post(
    "http://localhost:3001/api/results",
    json=result_data,
    headers=headers
)

# Rust
use serde_json::json;

let result_data = json!({
    "agent_id": "python-specialist-uuid",
    "agent_type": "python-specialist",
    "issue_id": "issue-123",
    "project_id": "project-abc",
    "result": {
        "status": "success",
        "files_created": ["src/api.py"],
        "decisions": ["Implemented REST API"]
    }
});

let response = client
    .post("http://localhost:3001/api/results")
    .header("Authorization", format!("Bearer {}", jwt_token))
    .json(&result_data)
    .send()
    .await?;
```

#### Response Schema

```json
{
  "id": "result-uuid-456",
  "stored": true,
  "storage_path": "/tmp/cco-sidecar/results/project-abc/issue-123/python-specialist.json",
  "next_agents": [
    {
      "agent_type": "test-engineer",
      "priority": "high",
      "reason": "Validation of implemented API"
    },
    {
      "agent_type": "security-auditor",
      "priority": "medium",
      "reason": "Security review of new endpoints"
    }
  ],
  "event_published": true,
  "event_id": "evt-789",
  "timestamp": "2025-11-18T10:05:00Z"
}
```

#### Status Codes

| Code | Description |
|------|-------------|
| `201 Created` | Result stored successfully |
| `400 Bad Request` | Invalid request schema |
| `401 Unauthorized` | Invalid or missing JWT token |
| `403 Forbidden` | Agent lacks `write_results` permission |
| `500 Internal Server Error` | Storage failed |

---

### POST /api/events/:event_type {#post-events}

Publish events to the event bus.

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `event_type` | Path | Yes | Event type (e.g., `agent_completed`) |

#### Request Schema

```json
{
  "event_type": "agent_completed",
  "publisher": "python-specialist-uuid",
  "topic": "implementation",
  "data": {
    "issue_id": "issue-123",
    "status": "success",
    "next_phase": "testing",
    "files_changed": ["src/api.py", "tests/test_api.py"],
    "custom_metadata": {
      "api_version": "v1",
      "endpoints_added": 5
    }
  },
  "correlation_id": "session-789",
  "ttl_seconds": 86400,
  "priority": "normal"
}
```

#### Request Examples

```bash
# cURL
curl -X POST \
  -H "Authorization: Bearer eyJhbGci..." \
  -H "Content-Type: application/json" \
  -d '{
    "event_type": "agent_completed",
    "publisher": "python-specialist-uuid",
    "topic": "implementation",
    "data": {"status": "success"}
  }' \
  http://localhost:3001/api/events/agent_completed

# Python
import requests

event_data = {
    "event_type": "agent_completed",
    "publisher": "python-specialist-uuid",
    "topic": "implementation",
    "data": {"status": "success"}
}

response = requests.post(
    "http://localhost:3001/api/events/agent_completed",
    json=event_data,
    headers={"Authorization": f"Bearer {jwt_token}"}
)

# Rust
let event_data = json!({
    "event_type": "agent_completed",
    "publisher": "python-specialist-uuid",
    "topic": "implementation",
    "data": {"status": "success"}
});

let response = client
    .post("http://localhost:3001/api/events/agent_completed")
    .header("Authorization", format!("Bearer {}", jwt_token))
    .json(&event_data)
    .send()
    .await?;
```

#### Response Schema

```json
{
  "event_id": "evt-uuid-789",
  "published": true,
  "subscribers_notified": [
    "test-engineer-uuid",
    "qa-engineer-uuid"
  ],
  "subscriber_count": 2,
  "timestamp": "2025-11-18T10:06:00Z",
  "topic": "implementation",
  "ttl_seconds": 86400
}
```

#### Status Codes

| Code | Description |
|------|-------------|
| `202 Accepted` | Event published successfully |
| `400 Bad Request` | Invalid event schema |
| `401 Unauthorized` | Invalid JWT token |
| `403 Forbidden` | Agent lacks `publish_events` permission |
| `500 Internal Server Error` | Event bus error |

---

### GET /api/events/wait/:event_type {#get-events-wait}

Long-polling subscription for events.

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `event_type` | Path | Yes | Event type to wait for |
| `timeout` | Query | No | Timeout in milliseconds (default: 30000) |
| `filter` | Query | No | Filter expression (e.g., `issue_id:issue-123`) |
| `since` | Query | No | Only events after this ID |

#### Request Examples

```bash
# cURL - Wait for agent_completed events
curl -H "Authorization: Bearer eyJhbGci..." \
  "http://localhost:3001/api/events/wait/agent_completed?timeout=30000&filter=issue_id:issue-123"

# Python - Long polling
import requests

def wait_for_event(event_type, timeout=30000):
    response = requests.get(
        f"http://localhost:3001/api/events/wait/{event_type}",
        params={"timeout": timeout, "filter": "issue_id:issue-123"},
        headers={"Authorization": f"Bearer {jwt_token}"},
        timeout=timeout/1000 + 5  # Add buffer
    )
    return response.json()

events = wait_for_event("agent_completed")

# Rust - Async polling
let response = client
    .get("http://localhost:3001/api/events/wait/agent_completed")
    .query(&[
        ("timeout", "30000"),
        ("filter", "issue_id:issue-123")
    ])
    .header("Authorization", format!("Bearer {}", jwt_token))
    .send()
    .await?;
```

#### Response Schema (when event arrives)

```json
{
  "events": [
    {
      "event_id": "evt-uuid-789",
      "event_type": "agent_completed",
      "publisher": "python-specialist-uuid",
      "topic": "implementation",
      "data": {
        "issue_id": "issue-123",
        "status": "success"
      },
      "timestamp": "2025-11-18T10:06:00Z",
      "correlation_id": "session-789"
    }
  ],
  "more_available": false,
  "next_cursor": "evt-uuid-790",
  "timestamp": "2025-11-18T10:06:00Z"
}
```

#### Response Schema (on timeout)

```json
{
  "events": [],
  "more_available": false,
  "next_cursor": null,
  "timeout": true,
  "timestamp": "2025-11-18T10:06:30Z"
}
```

#### Status Codes

| Code | Description |
|------|-------------|
| `200 OK` | Events returned or timeout reached |
| `400 Bad Request` | Invalid filter syntax |
| `401 Unauthorized` | Invalid JWT token |
| `408 Request Timeout` | Server-side timeout (rare) |

---

### POST /api/agents/spawn {#post-agents-spawn}

Spawn a new agent with context.

#### Request Schema

```json
{
  "agent_type": "python-specialist",
  "issue_id": "issue-124",
  "task": "Implement user authentication",
  "context_requirements": [
    "project_structure",
    "previous_decisions",
    "security_policies"
  ],
  "environment": {
    "PYTHON_VERSION": "3.11",
    "PROJECT_ROOT": "/Users/project",
    "API_BASE_URL": "http://localhost:8000"
  },
  "priority": "high"
}
```

#### Response Schema

```json
{
  "agent_id": "python-specialist-uuid-new",
  "spawned": true,
  "process_id": 12345,
  "context_injected": true,
  "jwt_token": "eyJhbGciOiJIUzI1NiIs...",
  "webhook_url": "/api/agents/python-specialist-uuid-new/status",
  "timestamp": "2025-11-18T10:10:00Z"
}
```

#### Status Codes

| Code | Description |
|------|-------------|
| `201 Created` | Agent spawned successfully |
| `400 Bad Request` | Invalid request |
| `401 Unauthorized` | Invalid JWT token |
| `403 Forbidden` | Agent lacks `spawn_agents` permission |
| `429 Too Many Requests` | Rate limit exceeded |
| `500 Internal Server Error` | Spawn failed |

---

### DELETE /api/cache/context/:issue_id {#delete-cache}

Clear cached context for an issue.

#### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `issue_id` | Path | Yes | Issue identifier |

#### Request Example

```bash
curl -X DELETE \
  -H "Authorization: Bearer eyJhbGci..." \
  http://localhost:3001/api/cache/context/issue-123
```

#### Response Schema

```json
{
  "cleared": true,
  "entries_removed": 3,
  "bytes_freed": 102400,
  "timestamp": "2025-11-18T10:15:00Z"
}
```

#### Status Codes

| Code | Description |
|------|-------------|
| `200 OK` | Cache cleared successfully |
| `401 Unauthorized` | Invalid JWT token |
| `404 Not Found` | No cached context for issue |

---

### GET /health {#get-health}

Health check endpoint (no authentication required).

#### Request Example

```bash
curl http://localhost:3001/health
```

#### Response Schema

```json
{
  "status": "healthy",
  "service": "orchestration-sidecar",
  "version": "1.0.0",
  "uptime_seconds": 3600,
  "checks": {
    "storage": "healthy",
    "event_bus": "healthy",
    "memory_usage_mb": 150,
    "cpu_usage_percent": 25.5,
    "active_agents": 5,
    "event_queue_size": 12,
    "disk_space_available_mb": 50000
  },
  "timestamp": "2025-11-18T10:20:00Z"
}
```

#### Status Codes

| Code | Description |
|------|-------------|
| `200 OK` | System healthy |
| `503 Service Unavailable` | System unhealthy |

---

### GET /status {#get-status}

Detailed system status (authentication required).

#### Request Example

```bash
curl -H "Authorization: Bearer eyJhbGci..." \
  http://localhost:3001/status
```

#### Response Schema

```json
{
  "agents": {
    "active": 5,
    "completed": 12,
    "failed": 0,
    "spawned_total": 17,
    "by_type": {
      "python-specialist": 2,
      "test-engineer": 1,
      "security-auditor": 1,
      "documentation-expert": 1
    },
    "avg_execution_time_ms": 4500
  },
  "storage": {
    "context_cache_entries": 45,
    "results_stored": 12,
    "total_size_mb": 25.5,
    "cache_hit_rate": 0.85,
    "storage_path": "/tmp/cco-sidecar"
  },
  "events": {
    "total_published": 156,
    "total_delivered": 312,
    "active_subscriptions": 8,
    "queue_depth": 3,
    "avg_delivery_time_ms": 15,
    "dead_letter_queue_size": 0
  },
  "performance": {
    "avg_response_time_ms": 45,
    "p95_response_time_ms": 89,
    "p99_response_time_ms": 120,
    "requests_per_second": 15.5,
    "errors_per_minute": 0.2
  },
  "timestamp": "2025-11-18T10:25:00Z"
}
```

---

## Error Codes

### Standard HTTP Status Codes

| Code | Name | Description |
|------|------|-------------|
| `200` | OK | Request successful |
| `201` | Created | Resource created |
| `202` | Accepted | Request accepted (async) |
| `400` | Bad Request | Invalid request syntax |
| `401` | Unauthorized | Missing or invalid authentication |
| `403` | Forbidden | Insufficient permissions |
| `404` | Not Found | Resource not found |
| `408` | Request Timeout | Request timed out |
| `429` | Too Many Requests | Rate limit exceeded |
| `500` | Internal Server Error | Server error |
| `503` | Service Unavailable | System unhealthy |

### Custom Error Codes

| Code | Description |
|------|-------------|
| `AUTH_001` | Invalid JWT token |
| `AUTH_002` | Expired JWT token |
| `AUTH_003` | Insufficient permissions |
| `CTX_001` | Context generation failed |
| `CTX_002` | Context too large (>10MB) |
| `EVT_001` | Event bus unavailable |
| `EVT_002` | Invalid event schema |
| `STR_001` | Storage write failed |
| `STR_002` | Storage read failed |
| `AGT_001` | Agent spawn failed |
| `AGT_002` | Unknown agent type |

### Error Response Schema

```json
{
  "error": "unauthorized",
  "message": "Invalid or expired JWT token",
  "code": "AUTH_001",
  "details": {
    "token_expired": true,
    "expiry_time": "2025-11-18T09:00:00Z"
  },
  "timestamp": "2025-11-18T10:00:00Z",
  "request_id": "req-uuid-123"
}
```

---

## Rate Limiting

### Limits by Agent Type

| Agent Type | Requests/Minute | Burst |
|-----------|-----------------|-------|
| Chief Architect | Unlimited | - |
| Coding Specialists | 60 | 10 |
| QA/Security | 60 | 10 |
| Documentation | 30 | 5 |
| Support Agents | 30 | 5 |

### Rate Limit Headers

```http
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 45
X-RateLimit-Reset: 1700000060
```

### Rate Limit Exceeded Response

```json
{
  "error": "rate_limit_exceeded",
  "message": "Too many requests. Please wait 30 seconds.",
  "code": "RATE_001",
  "retry_after_seconds": 30,
  "limit": 60,
  "timestamp": "2025-11-18T10:30:00Z"
}
```

---

## Examples

### Complete Agent Workflow

```python
import requests
import time

# Configuration
SIDECAR_URL = "http://localhost:3001/api"
JWT_TOKEN = "eyJhbGciOiJIUzI1NiIs..."
ISSUE_ID = "issue-123"
AGENT_TYPE = "python-specialist"

headers = {"Authorization": f"Bearer {JWT_TOKEN}"}

# 1. Get context
context_response = requests.get(
    f"{SIDECAR_URL}/context/{ISSUE_ID}/{AGENT_TYPE}",
    headers=headers
)
context = context_response.json()
print(f"Context retrieved: {len(context['context']['relevant_files'])} files")

# 2. Subscribe to events (in background thread)
def wait_for_architecture_event():
    response = requests.get(
        f"{SIDECAR_URL}/events/wait/architecture_defined",
        params={"timeout": 60000, "filter": f"issue_id:{ISSUE_ID}"},
        headers=headers
    )
    return response.json()

# 3. Do work (implement feature)
time.sleep(5)  # Simulated work

# 4. Store results
result_data = {
    "agent_id": "python-specialist-uuid",
    "agent_type": AGENT_TYPE,
    "issue_id": ISSUE_ID,
    "project_id": "project-abc",
    "result": {
        "status": "success",
        "files_created": ["src/api.py", "tests/test_api.py"],
        "decisions": ["Implemented REST API with FastAPI"],
        "metrics": {
            "execution_time_ms": 5000,
            "test_coverage": 95.0
        }
    }
}

result_response = requests.post(
    f"{SIDECAR_URL}/results",
    json=result_data,
    headers=headers
)
result = result_response.json()
print(f"Results stored: {result['id']}")
print(f"Next agents: {[a['agent_type'] for a in result['next_agents']]}")

# 5. Publish completion event
event_data = {
    "event_type": "implementation_complete",
    "publisher": "python-specialist-uuid",
    "topic": "implementation",
    "data": {
        "issue_id": ISSUE_ID,
        "status": "success",
        "files_changed": 2
    }
}

event_response = requests.post(
    f"{SIDECAR_URL}/events/implementation_complete",
    json=event_data,
    headers=headers
)
event = event_response.json()
print(f"Event published: {event['event_id']}")
print(f"Subscribers notified: {event['subscriber_count']}")
```

### Rust Agent Example

```rust
use reqwest::{Client, header::{HeaderMap, HeaderValue, AUTHORIZATION}};
use serde_json::{json, Value};
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new();
    let sidecar_url = "http://localhost:3001/api";
    let jwt_token = "eyJhbGciOiJIUzI1NiIs...";
    let issue_id = "issue-123";
    let agent_type = "rust-specialist";

    // Setup headers
    let mut headers = HeaderMap::new();
    headers.insert(
        AUTHORIZATION,
        HeaderValue::from_str(&format!("Bearer {}", jwt_token))?
    );

    // 1. Get context
    let context_url = format!("{}/context/{}/{}", sidecar_url, issue_id, agent_type);
    let context_response = client
        .get(&context_url)
        .headers(headers.clone())
        .send()
        .await?;

    let context: Value = context_response.json().await?;
    println!("Context retrieved");

    // 2. Do work
    tokio::time::sleep(Duration::from_secs(5)).await;

    // 3. Store results
    let result_data = json!({
        "agent_id": "rust-specialist-uuid",
        "agent_type": agent_type,
        "issue_id": issue_id,
        "project_id": "project-abc",
        "result": {
            "status": "success",
            "files_created": ["src/main.rs"],
            "decisions": ["Implemented high-performance API"]
        }
    });

    let result_response = client
        .post(&format!("{}/results", sidecar_url))
        .headers(headers.clone())
        .json(&result_data)
        .send()
        .await?;

    let result: Value = result_response.json().await?;
    println!("Results stored: {}", result["id"]);

    Ok(())
}
```

---

## See Also

- [Quick Start Guide](ORCHESTRATION_SIDECAR_QUICKSTART.md)
- [Agent Integration Guide](ORCHESTRATION_SIDECAR_AGENT_GUIDE.md)
- [Event System](ORCHESTRATION_SIDECAR_EVENTS.md)
- [CLI Reference](ORCHESTRATION_SIDECAR_CLI_REFERENCE.md)
- [Troubleshooting](ORCHESTRATION_SIDECAR_TROUBLESHOOTING.md)

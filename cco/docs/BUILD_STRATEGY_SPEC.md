# Build Strategy Specification
## Compile-Time Agent Embedding Implementation

**Version**: 1.0.0
**Date**: November 15, 2025

---

## Overview

This specification details the exact build strategy for embedding 117 agent definitions into the CCO binary at compile time.

## Build Approach: Macro-Based Embedding

### Core Strategy

Use a **macro-driven approach** with `include_str!()` for simplicity and reliability:

1. **Macro file generation** via build script
2. **Direct string embedding** at compile time
3. **Lazy parsing** at first access
4. **Zero runtime file I/O**

---

## Implementation Details

### 1. Build Script (`build.rs`)

```rust
// cco/build.rs
use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    // Existing build tasks
    println!("cargo:rerun-if-changed=../config/");
    println!("cargo:rerun-if-changed=../config/orchestra-config.json");

    // New: Agent embedding
    println!("cargo:rerun-if-changed=config/agents/");

    let git_hash = get_git_hash();
    println!("cargo:rustc-env=GIT_HASH={}", git_hash);

    let build_date = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    println!("cargo:rustc-env=BUILD_DATE={}", build_date);

    // Generate agent embeddings
    generate_agent_embeddings();

    let version = env::var("CCO_VERSION").unwrap_or_else(|_| "2025.11.2".to_string());
    println!("cargo:rustc-env=CCO_VERSION={}", version);

    validate_configs();
}

fn generate_agent_embeddings() {
    let agents_dir = Path::new("config/agents");
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_agents.rs");

    let mut output = String::new();
    output.push_str("// Auto-generated by build.rs - DO NOT EDIT\n\n");
    output.push_str("/// Embedded agent definitions\n");
    output.push_str("pub const EMBEDDED_AGENTS: &[(&str, &str)] = &[\n");

    let mut count = 0;

    // Scan agents directory
    if let Ok(entries) = fs::read_dir(agents_dir) {
        for entry in entries.flatten() {
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("md") {
                let filename = path.file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("unknown");

                // Validate the agent file
                if validate_agent_file(&path) {
                    // Generate include_str! entry
                    let relative_path = path.strip_prefix("config/agents/")
                        .unwrap_or(&path)
                        .to_string_lossy();

                    output.push_str(&format!(
                        "    (\"{}\", include_str!(\"../../config/agents/{}\")),\n",
                        filename, relative_path
                    ));

                    count += 1;
                }
            }
        }
    }

    output.push_str("];\n\n");
    output.push_str(&format!("pub const AGENT_COUNT: usize = {};\n", count));

    // Write the generated file
    fs::write(&dest_path, output).expect("Failed to write embedded_agents.rs");

    println!("cargo:warning=Embedded {} agent definitions", count);
}

fn validate_agent_file(path: &Path) -> bool {
    match fs::read_to_string(path) {
        Ok(content) => {
            // Check for YAML frontmatter
            if !content.starts_with("---") {
                eprintln!("Warning: Agent file missing frontmatter: {:?}", path);
                return false;
            }

            // Find closing ---
            let rest = &content[3..];
            if let Some(end) = rest.find("---") {
                let yaml = &rest[..end];

                // Check for required fields
                let has_name = yaml.contains("name:");
                let has_model = yaml.contains("model:");
                let has_description = yaml.contains("description:");

                if !has_name || !has_model || !has_description {
                    eprintln!("Warning: Agent file missing required fields: {:?}", path);
                    return false;
                }

                // Validate model value
                if yaml.contains("model: opus")
                    || yaml.contains("model: sonnet")
                    || yaml.contains("model: haiku") {
                    return true;
                } else {
                    eprintln!("Warning: Invalid model in agent file: {:?}", path);
                    return false;
                }
            }

            false
        }
        Err(e) => {
            eprintln!("Error reading agent file {:?}: {}", path, e);
            false
        }
    }
}
```

### 2. Modified `agents_config.rs`

```rust
// src/agents_config.rs

use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tracing::{info, warn};

// Include the generated embeddings
include!(concat!(env!("OUT_DIR"), "/embedded_agents.rs"));

/// Agent configuration with metadata
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Agent {
    pub name: String,
    pub model: String,
    pub description: String,
    pub tools: Vec<String>,
}

/// Container for all loaded agent configurations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentsConfig {
    pub agents: HashMap<String, Agent>,
}

impl AgentsConfig {
    pub fn new() -> Self {
        Self {
            agents: HashMap::new(),
        }
    }

    pub fn get(&self, name: &str) -> Option<&Agent> {
        self.agents.get(name)
    }

    pub fn all(&self) -> Vec<Agent> {
        self.agents.values().cloned().collect()
    }

    pub fn len(&self) -> usize {
        self.agents.len()
    }

    pub fn is_empty(&self) -> bool {
        self.agents.is_empty()
    }
}

/// Static lazy-loaded agents from embedded data
static AGENTS: Lazy<AgentsConfig> = Lazy::new(|| {
    load_embedded_agents()
});

/// Load all embedded agent definitions
fn load_embedded_agents() -> AgentsConfig {
    let mut config = AgentsConfig::new();
    let mut loaded = 0;
    let mut errors = 0;

    for (name, content) in EMBEDDED_AGENTS {
        match parse_agent_from_content(name, content) {
            Some(agent) => {
                config.agents.insert(agent.name.clone(), agent);
                loaded += 1;
            }
            None => {
                warn!("Failed to parse embedded agent: {}", name);
                errors += 1;
            }
        }
    }

    info!(
        "âœ“ Loaded {} embedded agents ({} errors)",
        loaded, errors
    );

    config
}

/// Parse agent from embedded string content
fn parse_agent_from_content(filename: &str, content: &str) -> Option<Agent> {
    let frontmatter = parse_frontmatter(content)?;

    // Use filename as fallback for name
    let name = frontmatter.name.unwrap_or_else(|| filename.to_string());
    let model = frontmatter.model?;
    let description = frontmatter.description?;

    let tools = if let Some(tools_str) = frontmatter.tools {
        tools_str
            .split(',')
            .map(|t| t.trim().to_string())
            .filter(|t| !t.is_empty())
            .collect()
    } else {
        Vec::new()
    };

    Some(Agent {
        name,
        model,
        description,
        tools,
    })
}

/// YAML frontmatter data structure
#[derive(Debug, Clone)]
struct FrontmatterData {
    name: Option<String>,
    model: Option<String>,
    description: Option<String>,
    tools: Option<String>,
}

/// Parse YAML frontmatter from content
fn parse_frontmatter(content: &str) -> Option<FrontmatterData> {
    if !content.starts_with("---") {
        return None;
    }

    let rest = &content[3..];
    let closing_pos = rest.find("---")?;
    let yaml_content = &rest[..closing_pos];

    let mut data = FrontmatterData {
        name: None,
        model: None,
        description: None,
        tools: None,
    };

    for line in yaml_content.lines() {
        let line = line.trim();

        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        if let Some(colon_pos) = line.find(':') {
            let key = line[..colon_pos].trim();
            let value = line[colon_pos + 1..].trim();

            let value = if (value.starts_with('"') && value.ends_with('"'))
                || (value.starts_with('\'') && value.ends_with('\''))
            {
                &value[1..value.len() - 1]
            } else {
                value
            };

            match key {
                "name" => data.name = Some(value.to_string()),
                "model" => data.model = Some(value.to_string()),
                "description" => data.description = Some(value.to_string()),
                "tools" => data.tools = Some(value.to_string()),
                _ => {}
            }
        }
    }

    Some(data)
}

/// Public API to load agents
///
/// Returns embedded agents in production, or from ENV override in development
pub fn load_agents() -> AgentsConfig {
    // Development override for testing
    #[cfg(debug_assertions)]
    if let Ok(agents_dir) = std::env::var("CCO_AGENTS_DIR") {
        info!("Development mode: Loading agents from {}", agents_dir);
        return load_agents_from_directory(&agents_dir);
    }

    // Production: Use embedded agents
    AGENTS.clone()
}

/// Load agents from directory (development only)
#[cfg(debug_assertions)]
fn load_agents_from_directory(dir: &str) -> AgentsConfig {
    use std::fs;
    use std::path::PathBuf;

    let mut config = AgentsConfig::new();
    let agents_dir = PathBuf::from(dir);

    if !agents_dir.exists() {
        warn!("Agents directory not found: {:?}", agents_dir);
        return config;
    }

    if let Ok(entries) = fs::read_dir(&agents_dir) {
        for entry in entries.flatten() {
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("md") {
                if let Ok(content) = fs::read_to_string(&path) {
                    let filename = path.file_stem()
                        .and_then(|s| s.to_str())
                        .unwrap_or("unknown");

                    if let Some(agent) = parse_agent_from_content(filename, &content) {
                        config.agents.insert(agent.name.clone(), agent);
                    }
                }
            }
        }
    }

    info!("Loaded {} agents from directory: {}", config.len(), dir);
    config
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_embedded_agents_load() {
        let agents = load_embedded_agents();
        assert!(!agents.is_empty());
        assert!(agents.len() > 0);
    }

    #[test]
    fn test_parse_frontmatter() {
        let content = r#"---
name: test-agent
model: sonnet
description: A test agent
tools: Read, Write, Edit
---

# Agent content here
"#;

        let result = parse_frontmatter(content);
        assert!(result.is_some());

        let data = result.unwrap();
        assert_eq!(data.name, Some("test-agent".to_string()));
        assert_eq!(data.model, Some("sonnet".to_string()));
    }

    #[test]
    fn test_agent_count_matches() {
        let agents = load_embedded_agents();
        assert_eq!(agents.len(), AGENT_COUNT);
    }
}
```

### 3. Cargo.toml Dependencies

```toml
[dependencies]
# Add lazy initialization
once_cell = "1.19"

# Existing dependencies remain unchanged
```

---

## Build Process Flow

### Step-by-Step Execution

1. **Developer runs `cargo build`**
   - Triggers build.rs execution

2. **build.rs scans `config/agents/`**
   - Finds all .md files
   - Validates YAML frontmatter
   - Generates `$OUT_DIR/embedded_agents.rs`

3. **Generated file contains**
   ```rust
   pub const EMBEDDED_AGENTS: &[(&str, &str)] = &[
       ("chief-architect", include_str!("../../config/agents/chief-architect.md")),
       ("python-specialist", include_str!("../../config/agents/python-specialist.md")),
       // ... 115 more
   ];
   pub const AGENT_COUNT: usize = 117;
   ```

4. **agents_config.rs includes generated file**
   ```rust
   include!(concat!(env!("OUT_DIR"), "/embedded_agents.rs"));
   ```

5. **Compilation embeds all agent strings**
   - Strings stored in binary's .rodata section
   - No runtime file access needed

6. **Runtime initialization**
   - First API call triggers lazy parsing
   - YAML parsed once, cached forever

---

## Development Workflow

### Adding a New Agent

```bash
# 1. Create agent file
cat > cco/config/agents/new-specialist.md << 'EOF'
---
name: new-specialist
model: haiku
description: Specialist for new technology
tools: Read, Write, Edit
---

Agent instructions here...
EOF

# 2. Build automatically includes it
cargo build

# 3. Verify inclusion
cargo run -- serve
curl http://localhost:11437/api/agents | jq '.agents[] | select(.name == "new-specialist")'
```

### Modifying Existing Agent

```bash
# 1. Edit agent file
vim cco/config/agents/python-specialist.md

# 2. Rebuild (triggered by cargo watch)
cargo build

# 3. New binary has updated agent
```

### Development Mode Override

```bash
# Use external directory during development
export CCO_AGENTS_DIR=/path/to/test/agents
cargo run -- serve

# Unset to use embedded agents
unset CCO_AGENTS_DIR
cargo run -- serve
```

---

## Error Handling

### Build-Time Errors

```rust
// Invalid YAML frontmatter
// Build continues but warns:
cargo:warning=Agent file missing required fields: config/agents/broken.md

// File read error
// Build continues but warns:
Error reading agent file config/agents/missing.md: No such file

// Result: Binary built with valid agents only
```

### Runtime Errors

```rust
// Malformed embedded content
// Agent skipped, logged:
WARN Failed to parse embedded agent: broken-agent

// API returns only valid agents
GET /api/agents -> Returns successfully parsed agents
```

---

## Performance Characteristics

### Compile-Time Impact

| Metric | Value |
|--------|-------|
| Build time increase | ~2-3 seconds |
| Binary size increase | ~500KB |
| Compile memory usage | +50MB peak |

### Runtime Performance

| Metric | Value |
|--------|-------|
| Startup parsing | <10ms for 117 agents |
| Memory usage | ~200KB parsed structures |
| API response time | <1ms (from memory) |
| File I/O operations | 0 (zero) |

---

## Testing Strategy

### Unit Tests

```rust
#[test]
fn test_all_agents_embedded() {
    assert_eq!(EMBEDDED_AGENTS.len(), 117);
}

#[test]
fn test_agent_parsing() {
    let agents = load_embedded_agents();
    assert_eq!(agents.len(), AGENT_COUNT);
}

#[test]
fn test_specific_agents_exist() {
    let agents = load_embedded_agents();
    assert!(agents.get("chief-architect").is_some());
    assert!(agents.get("python-specialist").is_some());
}
```

### Integration Tests

```rust
#[tokio::test]
async fn test_agents_api_endpoint() {
    let response = get("/api/agents").await;
    assert_eq!(response.status(), 200);

    let body: AgentsListResponse = response.json().await;
    assert_eq!(body.agents.len(), 117);
}

#[tokio::test]
async fn test_specific_agent_endpoint() {
    let response = get("/api/agents/chief-architect").await;
    assert_eq!(response.status(), 200);

    let agent: Agent = response.json().await;
    assert_eq!(agent.model, "opus");
}
```

### Build Tests

```bash
# Test clean build
rm -rf target/
cargo build --release
./target/release/cco --version

# Test incremental build
touch config/agents/python-specialist.md
cargo build --release

# Test with missing agents directory
mv config/agents config/agents.bak
cargo build # Should handle gracefully
mv config/agents.bak config/agents
```

---

## Security Considerations

### Compile-Time Security

1. **No code execution** - Agent files are data only
2. **Validated YAML** - Build script checks format
3. **Known content** - All agents in version control
4. **No injection** - Strings embedded as literals

### Runtime Security

1. **No file access** - Zero filesystem operations
2. **Read-only data** - Agents immutable after compile
3. **Memory safe** - Rust ownership prevents issues
4. **No external dependencies** - Self-contained

---

## Migration Checklist

### Pre-Migration
- [ ] Backup existing ~/.claude/agents/
- [ ] Verify all 117 agents have valid YAML
- [ ] Check git repository has space (~500KB)

### Migration Steps
- [ ] Create cco/config/agents/ directory
- [ ] Copy all .md files to new location
- [ ] Update build.rs with embedding logic
- [ ] Modify agents_config.rs for embedded data
- [ ] Add once_cell dependency
- [ ] Run cargo build and verify
- [ ] Test all API endpoints

### Post-Migration
- [ ] Verify binary works without ~/.claude/agents/
- [ ] Test on fresh system
- [ ] Update documentation
- [ ] Remove old file loading code (optional)

---

## Summary

This build strategy provides:

1. **Simplicity** - Minimal code changes
2. **Reliability** - Uses proven Rust features
3. **Performance** - Zero runtime overhead
4. **Maintainability** - Clear, documented approach
5. **Compatibility** - Works with existing API

The macro-based embedding approach is recommended for its balance of simplicity and effectiveness.